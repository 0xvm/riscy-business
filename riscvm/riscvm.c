/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "riscvm.c" -x none -pipe -fwrapv -fno-strict-aliasing -g -lm -o "riscvm" */
/* Compile hash: 3yRF316SvDmqYnDkveN73j7PiY2f */
/* ------------------------------ DIRECTIVES -------------------------------- */
#define _CRT_SECURE_NO_WARNINGS
#define NELUA_NIL (nlniltype){}
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
#define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
#define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
#define NELUA_INLINE inline
#else
#define NELUA_INLINE
#endif
#include <stddef.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
#define NELUA_EXTERN extern "C"
#else
#define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
#endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
NELUA_EXTERN void __ubsan_handle_builtin_unreachable( void* ) __attribute__( ( weak ) );
#define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
#define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
#define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
#define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
#define NELUA_NORETURN __declspec(noreturn)
#else
#define NELUA_NORETURN
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
#define NELUA_MAYALIAS __attribute__((may_alias))
#else
#define NELUA_MAYALIAS
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
#define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
#define NELUA_LIKELY(x) (x)
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
#define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
#define NELUA_UNLIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
#define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#define NELUA_NOINLINE __declspec(noinline)
#else
#define NELUA_NOINLINE
#endif
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct nlniltype
{} nlniltype;
typedef struct nlniltype nltype;
typedef struct machine_Machine machine_Machine;
typedef machine_Machine* machine_Machine_ptr;
struct machine_Machine
{
    bool running;
    int64_t pc;
    uint64_t regs[ 32 ];
    uint8_t memory[ 134217728 ];
    int64_t exitcode;
};
typedef uint8_t* nluint8_arr0_ptr;
typedef FILE* FILE_ptr;
typedef struct NELUA_MAYALIAS nluint8_arr134217728
{
    uint8_t v[ 134217728 ];
} nluint8_arr134217728;
typedef union NELUA_MAYALIAS nluint8_arr134217728_cast
{
    nluint8_arr134217728 a; uint8_t p[ 134217728 ];
} nluint8_arr134217728_cast;
typedef struct NELUA_MAYALIAS nluint64_arr32
{
    uint64_t v[ 32 ];
} nluint64_arr32;
typedef union NELUA_MAYALIAS nluint64_arr32_cast
{
    nluint64_arr32 a; uint64_t p[ 32 ];
} nluint64_arr32_cast;
static NELUA_INLINE uint32_t machine_Machine_fetch( machine_Machine_ptr self );
typedef uint32_t* nluint32_ptr;
static NELUA_INLINE int8_t machine_Machine_read_1( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE int16_t machine_Machine_read_2( machine_Machine_ptr self, nlniltype T, uint64_t addr );
typedef uint16_t* nluint16_ptr;
static NELUA_INLINE int32_t machine_Machine_read_3( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE int64_t machine_Machine_read_4( machine_Machine_ptr self, nlniltype T, uint64_t addr );
typedef uint64_t* nluint64_ptr;
static NELUA_INLINE uint8_t machine_Machine_read_5( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE uint16_t machine_Machine_read_6( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE uint32_t machine_Machine_read_7( machine_Machine_ptr self, nlniltype T, uint64_t addr );
static NELUA_INLINE void* machine_Machine_getptr( machine_Machine_ptr self, uint64_t addr );
static NELUA_INLINE void machine_Machine_write_1( machine_Machine_ptr self, uint64_t addr, uint8_t val );
static NELUA_INLINE void machine_Machine_write_2( machine_Machine_ptr self, uint64_t addr, uint16_t val );
static NELUA_INLINE void machine_Machine_write_3( machine_Machine_ptr self, uint64_t addr, uint32_t val );
static NELUA_INLINE void machine_Machine_write_4( machine_Machine_ptr self, uint64_t addr, uint64_t val );
static uint64_t machine_Machine_handle_syscall( machine_Machine_ptr self, uint64_t code );
static NELUA_INLINE void machine_Machine_execute( machine_Machine_ptr self, uint32_t inst );
static NELUA_INLINE int64_t nelua_shl_nlint64( int64_t a, int64_t b );
static NELUA_INLINE int64_t nelua_shr_nlint64( int64_t a, int64_t b );
static NELUA_INLINE int64_t nelua_asr_nlint64( int64_t a, int64_t b );
static NELUA_INLINE __int128 nelua_shr_nlint128( __int128 a, __int128 b );
static NELUA_NOINLINE void machine_Machine_run( machine_Machine_ptr self );

#define get_reg(x) ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ x ]

/* ------------------------------ DEFINITIONS ------------------------------- */
#define panic(...) do { printf(__VA_ARGS__); __debugbreak(); } while(0)
void machine_Machine_loadfile( machine_Machine_ptr self, const char* filename )
{
    FILE_ptr fp = fopen( filename, "rb" );
    if( ( !( fp != NULL ) ) )
    {
        puts("failed to open file");
    }
    fseek( fp, 0, SEEK_END );
    long size = ftell( fp );
    fseek( fp, 0, SEEK_SET );
    fread( ( void* )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ 4096 ] ), ( size_t )size, 1U, fp );
    fclose( fp );
    ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 2 ] = 134217728U;
    self->pc = 4096;
}
uint32_t machine_Machine_fetch( machine_Machine_ptr self )
{
    return ( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ self->pc ] ) );
}
int8_t machine_Machine_read_1( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int8_t )( *( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
int16_t machine_Machine_read_2( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int16_t )( *( nluint16_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
int32_t machine_Machine_read_3( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int32_t )( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
int64_t machine_Machine_read_4( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( int64_t )( *( nluint64_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
uint8_t machine_Machine_read_5( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( *( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
uint16_t machine_Machine_read_6( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( *( nluint16_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
uint32_t machine_Machine_read_7( machine_Machine_ptr self, nlniltype T, uint64_t addr )
{
    return ( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) );
}
void* machine_Machine_getptr( machine_Machine_ptr self, uint64_t addr )
{
    return ( void* )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] );
}
void machine_Machine_write_1( machine_Machine_ptr self, uint64_t addr, uint8_t val )
{
    ( *( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void machine_Machine_write_2( machine_Machine_ptr self, uint64_t addr, uint16_t val )
{
    ( *( nluint16_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void machine_Machine_write_3( machine_Machine_ptr self, uint64_t addr, uint32_t val )
{
    ( *( nluint32_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void machine_Machine_write_4( machine_Machine_ptr self, uint64_t addr, uint64_t val )
{
    ( *( nluint64_ptr )( &( ( ( nluint8_arr134217728_cast* )&self->memory )->a ).v[ addr ] ) ) = val;
}
void nelua_print_1( char* a1 )
{
    fputs( a1 != NULL ? a1 : "(null cstring)", stdout );
    fputs( "\n", stdout );
    fflush( stdout );
}
void nelua_print_2( int64_t a1 )
{
    fprintf( stdout, "%lli", ( long long )a1 );
    fputs( "\n", stdout );
    fflush( stdout );
}

NELUA_INLINE uint32_t syscall_0_stub( uint32_t id )
{
    register void* a1 asm( "r10" );
    void* a2;
    register void* a3 asm( "r8" );
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( a2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_1_stub( uint32_t id, uint64_t _1 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    void* a2;
    register void* a3 asm( "r8" );
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( a2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_2_stub( uint32_t id, uint64_t _1, uint64_t _2 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register void* a3 asm( "r8" );
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_3_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register void* a4 asm( "r9" );

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_4_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "syscall\n"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 ), "r"( a4 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_5_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register void* unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $48, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "syscall\n"
                  "add $48, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 ), "r"( a4 ), [ a5 ] "re"( ( void* )( _5 ) )
                  : "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_6_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile(
        "sub $64, %%rsp\n"
        "movq %[a5], 40(%%rsp)\n"
        "movq %[a6], 48(%%rsp)\n"
        "syscall\n"
        "add $64, %%rsp"
        : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
        : "a"( id ), "r"( a1 ), "d"( _2 ), "r"( a3 ), "r"( a4 ), [ a5 ] "re"( _5 ), [ a6 ] "re"( _6 )
        : "memory", "cc"
        );
    return status;
}

NELUA_INLINE uint32_t syscall_7_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $64, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "syscall\n"
                  "add $64, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_8_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $80, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "syscall\n"
                  "add $80, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_9_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $80, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "syscall\n"
                  "add $80, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_10_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $96, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "syscall\n"
                  "add $96, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_11_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10, uint64_t _11 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $96, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "movq %[a11], 88(%%rsp)\n"
                  "syscall\n"
                  "add $96, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 ),
                  [ a11 ] "re"( _11 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_12_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10, uint64_t _11, uint64_t _12 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $112, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "movq %[a11], 88(%%rsp)\n"
                  "movq %[a12], 96(%%rsp)\n"
                  "syscall\n"
                  "add $112, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 ),
                  [ a11 ] "re"( _11 ),
                  [ a12 ] "re"( _12 )
                  : "memory", "cc" );
    return status;
}

NELUA_INLINE uint32_t syscall_13_stub( uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9, uint64_t _10, uint64_t _11, uint64_t _12, uint64_t _13 )
{
    register uint64_t a1 asm( "r10" ) = _1;
    register uint64_t a3 asm( "r8" ) = _3;
    register uint64_t a4 asm( "r9" ) = _4;

    void* unused_output;
    register uint64_t unused_output2 asm( "r11" );

    uint32_t status;
    asm volatile( "sub $112, %%rsp\n"
                  "movq %[a5], 40(%%rsp)\n"
                  "movq %[a6], 48(%%rsp)\n"
                  "movq %[a7], 56(%%rsp)\n"
                  "movq %[a8], 64(%%rsp)\n"
                  "movq %[a9], 72(%%rsp)\n"
                  "movq %[a10], 80(%%rsp)\n"
                  "movq %[a11], 88(%%rsp)\n"
                  "movq %[a12], 96(%%rsp)\n"
                  "movq %[a13], 104(%%rsp)\n"
                  "syscall\n"
                  "add $112, %%rsp"
                  : "=a"( status ), "=r"( a1 ), "=d"( _2 ), "=r"( a3 ), "=r"( a4 ), "=c"( unused_output ), "=r"( unused_output2 )
                  : "a"( id ),
                  "r"( a1 ),
                  "d"( _2 ),
                  "r"( a3 ),
                  "r"( a4 ),
                  [ a5 ] "re"( _5 ),
                  [ a6 ] "re"( _6 ),
                  [ a7 ] "re"( _7 ),
                  [ a8 ] "re"( _8 ),
                  [ a9 ] "re"( _9 ),
                  [ a10 ] "re"( _10 ),
                  [ a11 ] "re"( _11 ),
                  [ a12 ] "re"( _12 ),
                  [ a13 ] "re"( _13 )
                  : "memory", "cc" );
    return status;
}


NELUA_INLINE uint64_t machine_Machine_handle_syscall( machine_Machine_ptr self, uint64_t code )
{
    switch( code )
    {
    case 10000:
    {
        self->running = false;
        self->exitcode = get_reg(10);
        break;
    }
    case 10001:
    {
        panic("aborted!");
        break;
    }
    case 10006:
    {
        void* src = machine_Machine_getptr( self, get_reg(10) );
        void* dest = machine_Machine_getptr( self, get_reg(11) );
        void* res = memcpy( dest, src, ( size_t )get_reg(12) );
        return ( uint64_t )res;
    }
    case 10007:
    {
        void* dest = machine_Machine_getptr( self, get_reg(10) );
        void* res = memset( dest, ( int )get_reg(11), ( size_t )get_reg(12) );
        return ( uint64_t )res;
    }
    case 10008:
    {
        void* src = machine_Machine_getptr( self, get_reg( 10 ) );
        void* dest = machine_Machine_getptr( self, get_reg( 11 ) );
        void* res = memmove( dest, src, ( size_t )get_reg( 12 ) );
        return ( uint64_t )res;
    }
    case 10009:
    {
        void* src1 = machine_Machine_getptr( self, get_reg( 10 ) );
        void* src2 = machine_Machine_getptr( self, get_reg( 11 ) );
        return ( uint64_t )memcmp( src1, src2, ( size_t )get_reg( 12 ) );
    }
    case 10101:
    {
        char* s = ( char* )machine_Machine_getptr( self, get_reg( 10 ) );
        nelua_print_1( s );
        break;
    }
    case 10102:
    {
        nelua_print_2( get_reg(10) );
        break;
    }
    case 20000:
    {
        uint32_t id = ( uint32_t )get_reg(10);
        uint64_t* args = ( uint64_t* )machine_Machine_getptr( self, get_reg(11) );
        size_t nargs = ( size_t )get_reg(12);
        switch( nargs )
        {
            case 0:
            {
                return ( uint64_t )syscall_0_stub( id );
            }
            case 1:
            {
                return ( uint64_t )syscall_1_stub( id, args[0] );
            }
            case 2:
            {
                return ( uint64_t )syscall_2_stub( id, args[0], args[1] );
            }
            case 3:
            {
                return ( uint64_t )syscall_3_stub( id, args[0], args[1], args[2] );
            }
            case 4:
            {
                return ( uint64_t )syscall_4_stub( id, args[0], args[1], args[2], args[3] );
            }
            case 5:
            {
                return ( uint64_t )syscall_5_stub( id, args[0], args[1], args[2], args[3], args[4] );
            }
            case 6:
            {
                return ( uint64_t )syscall_6_stub( id, args[0], args[1], args[2], args[3], args[4], args[5] );
            }
            case 7:
            {
                return ( uint64_t )syscall_7_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6] );
            }
            case 8:
            {
                return ( uint64_t )syscall_8_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7] );
            }
            case 9:
            {
                return ( uint64_t )syscall_9_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8] );
            }
            case 10:
            {
                return ( uint64_t )syscall_10_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9] );
            }
            case 11:
            {
                return ( uint64_t )syscall_11_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10] );
            }
            case 12:
            {
                return ( uint64_t )syscall_12_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11] );
            }
            case 13:
            {
                return ( uint64_t )syscall_13_stub( id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12] );
            }
            default:
            {
                panic("too many arguments for windows syscall");
                break;
            }
        }
    }
    default:
    {
        panic("illegal system call %llu (0x%llX)\n", code, code);
        break;
    }
    }
    return 0U;
}
int64_t nelua_shl_nlint64( int64_t a, int64_t b )
{
    if( NELUA_LIKELY( b >= 0 && b < 64 ) )
    {
        return ( ( uint64_t )a ) << b;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -64 ) )
    {
        return ( uint64_t )a >> -b;
    }
    else
    {
        return 0;
    }
}
int64_t nelua_shr_nlint64( int64_t a, int64_t b )
{
    if( NELUA_LIKELY( b >= 0 && b < 64 ) )
    {
        return ( uint64_t )a >> b;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -64 ) )
    {
        return ( uint64_t )a << -b;
    }
    else
    {
        return 0;
    }
}
int64_t nelua_asr_nlint64( int64_t a, int64_t b )
{
    if( NELUA_LIKELY( b >= 0 && b < 64 ) )
    {
        return a >> b;
    }
    else if( NELUA_UNLIKELY( b >= 64 ) )
    {
        return a < 0 ? -1 : 0;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -64 ) )
    {
        return a << -b;
    }
    else
    {
        return 0;
    }
}
__int128 nelua_shr_nlint128( __int128 a, __int128 b )
{
    if( NELUA_LIKELY( b >= 0 && b < 128 ) )
    {
        return ( unsigned __int128 )a >> b;
    }
    else if( NELUA_UNLIKELY( b < 0 && b > -128 ) )
    {
        return ( unsigned __int128 )a << -b;
    }
    else
    {
        return 0;
    }
}
void machine_Machine_execute( machine_Machine_ptr self, uint32_t inst )
{
    uint32_t opcode = ( ( inst >> 0 ) & 127 );
    uint32_t rd = ( ( inst >> 7 ) & 31 );
    uint32_t rs1 = ( ( inst >> 15 ) & 31 );
    uint32_t rs2 = ( ( inst >> 20 ) & 31 );
    switch( opcode )
    {
    case 0x3:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        uint64_t addr = ( ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ] + ( uint64_t )imm );
        int64_t val;
        switch( funct3 )
        {
        case 0x0:
        {
            val = ( int64_t )machine_Machine_read_1( self, NELUA_NIL, addr );
            break;
        }
        case 0x1:
        {
            val = ( int64_t )machine_Machine_read_2( self, NELUA_NIL, addr );
            break;
        }
        case 0x2:
        {
            val = ( int64_t )machine_Machine_read_3( self, NELUA_NIL, addr );
            break;
        }
        case 0x3:
        {
            val = machine_Machine_read_4( self, NELUA_NIL, addr );
            break;
        }
        case 0x4:
        {
            val = ( int64_t )machine_Machine_read_5( self, NELUA_NIL, addr );
            break;
        }
        case 0x5:
        {
            val = ( int64_t )machine_Machine_read_6( self, NELUA_NIL, addr );
            break;
        }
        case 0x6:
        {
            val = ( int64_t )machine_Machine_read_7( self, NELUA_NIL, addr );
            break;
        }
        default:
        {
            panic("illegal load instruction");
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x23:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( ( inst >> 20 ) & 4064 ) | ( ( inst >> 7 ) & 31 ) ) << 20 ) ) >> 20 );
        uint64_t addr = ( ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ] + ( uint64_t )imm );
        uint64_t val = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        switch( funct3 )
        {
        case 0x0:
        {
            machine_Machine_write_1( self, addr, ( uint8_t )val );
            break;
        }
        case 0x1:
        {
            machine_Machine_write_2( self, addr, ( uint16_t )val );
            break;
        }
        case 0x2:
        {
            machine_Machine_write_3( self, addr, ( uint32_t )val );
            break;
        }
        case 0x3:
        {
            machine_Machine_write_4( self, addr, val );
            break;
        }
        default:
        {
            panic("illegal store instruction");
            break;
        }
        }
        break;
    }
    case 0x13:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        uint32_t shamt = ( ( inst >> 20 ) & 63 );
        int64_t val = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        switch( funct3 )
        {
        case 0x0:
        {
            val = ( val + imm );
            break;
        }
        case 0x1:
        {
            val = nelua_shl_nlint64( val, shamt );
            break;
        }
        case 0x2:
        {
            if( ( val < imm ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x3:
        {
            if( ( ( uint64_t )val < ( uint64_t )imm ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x4:
        {
            val = ( val ^ imm );
            break;
        }
        case 0x5:
        {
            uint32_t funct6 = ( ( inst >> 26 ) & 63 );
            switch( ( funct6 >> 4 ) )
            {
            case 0x0:
            {
                val = nelua_shr_nlint64( val, shamt );
                break;
            }
            case 0x1:
            {
                val = nelua_asr_nlint64( val, shamt );
                break;
            }
            default:
            {
                panic("illegal op-imm shift instruction");
                break;
            }
            }
            break;
        }
        case 0x6:
        {
            val = ( val | imm );
            break;
        }
        case 0x7:
        {
            val = ( val & imm );
            break;
        }
        default:
        {
            panic("illegal op-imm instruction");
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x1b:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        int64_t val = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        switch( funct3 )
        {
        case 0x0:
        {
            val = ( int64_t )( int32_t )( val + imm );
            break;
        }
        case 0x1:
        {
            val = ( int64_t )( int32_t )nelua_shl_nlint64( val, imm );
            break;
        }
        case 0x5:
        {
            uint32_t shamt = rs2;
            uint32_t funct7 = ( ( inst >> 25 ) & 127 );
            switch( ( funct7 >> 5 ) )
            {
            case 0x0:
            {
                val = ( int64_t )( int32_t )nelua_shr_nlint64( val, shamt );
                break;
            }
            case 0x1:
            {
                val = ( int64_t )( int32_t )nelua_asr_nlint64( val, shamt );
                break;
            }
            default:
            {
                panic("illegal op-imm-32 shift instruction");
                break;
            }
            }
            break;
        }
        default:
        {
            panic("illegal op-imm-32 instruction");
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x33:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        uint32_t funct7 = ( ( inst >> 25 ) & 127 );
        int64_t val1 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        int64_t val2 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        int64_t val;
        switch( ( ( funct7 << 3 ) | funct3 ) )
        {
        case 0x0:
        {
            val = ( val1 + val2 );
            break;
        }
        case 0x100:
        {
            val = ( val1 - val2 );
            break;
        }
        case 0x1:
        {
            val = nelua_shl_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x2:
        {
            if( ( val1 < val2 ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x3:
        {
            if( ( ( uint64_t )val1 < ( uint64_t )val2 ) )
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x4:
        {
            val = ( val1 ^ val2 );
            break;
        }
        case 0x5:
        {
            val = nelua_shr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x105:
        {
            val = nelua_asr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x6:
        {
            val = ( val1 | val2 );
            break;
        }
        case 0x7:
        {
            val = ( val1 & val2 );
            break;
        }
        case 0x8:
        {
            val = ( val1 * val2 );
            break;
        }
        case 0x9:
        {
            val = ( int64_t )( uint64_t )nelua_shr_nlint128( ( ( __int128 )val1 * ( __int128 )val2 ), 64 );
            break;
        }
        case 0xa:
        {
            val = ( int64_t )( uint64_t )nelua_shr_nlint128( ( ( __int128 )val1 * ( __int128 )( uint64_t )val2 ), 64 );
            break;
        }
        case 0xb:
        {
            val = ( int64_t )( uint64_t )nelua_shr_nlint128( ( ( __int128 )( uint64_t )val1 * ( __int128 )( uint64_t )val2 ), 64 );
            break;
        }
        case 0xc:
        {
            int64_t dividend = val1;
            int64_t divisor = val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -9223372036854775807LL - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = ( -9223372036854775807LL - 1 );
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( dividend / divisor );
            }
            break;
        }
        case 0xd:
        {
            uint64_t dividend = ( uint64_t )val1;
            uint64_t divisor = ( uint64_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( int64_t )( dividend / divisor );
            }
            break;
        }
        case 0xe:
        {
            int64_t dividend = val1;
            int64_t divisor = val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -9223372036854775807LL - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = 0;
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = dividend;
            }
            else
            {
                val = ( dividend % divisor );
            }
            break;
        }
        case 0xf:
        {
            uint64_t dividend = ( uint64_t )val1;
            uint64_t divisor = ( uint64_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = ( int64_t )dividend;
            }
            else
            {
                val = ( int64_t )( dividend % divisor );
            }
            break;
        }
        default:
        {
            panic("illegal op instruction");
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x3b:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        uint32_t funct7 = ( ( inst >> 25 ) & 127 );
        int64_t val1 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        int64_t val2 = ( int64_t )( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        int64_t val;
        switch( ( ( funct7 << 3 ) | funct3 ) )
        {
        case 0x0:
        {
            val = ( int64_t )( int32_t )( val1 + val2 );
            break;
        }
        case 0x100:
        {
            val = ( int64_t )( int32_t )( val1 - val2 );
            break;
        }
        case 0x1:
        {
            val = ( int64_t )( int32_t )nelua_shl_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x5:
        {
            val = ( int64_t )( int32_t )nelua_shr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x105:
        {
            val = ( int64_t )( int32_t )nelua_asr_nlint64( val1, ( val2 & 0x1f ) );
            break;
        }
        case 0x8:
        {
            val = ( int64_t )( ( int32_t )val1 * ( int32_t )val2 );
            break;
        }
        case 0xc:
        {
            int32_t dividend = ( int32_t )val1;
            int32_t divisor = ( int32_t )val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -2147483647 - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = -2147483648LL;
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( int64_t )( dividend / divisor );
            }
            break;
        }
        case 0xd:
        {
            uint32_t dividend = ( uint32_t )val1;
            uint32_t divisor = ( uint32_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = -1;
            }
            else
            {
                val = ( int64_t )( int32_t )( dividend / divisor );
            }
            break;
        }
        case 0xe:
        {
            int32_t dividend = ( int32_t )val1;
            int32_t divisor = ( int32_t )val2;
            if( NELUA_UNLIKELY( ( ( dividend == ( -2147483647 - 1 ) ) && ( divisor == -1 ) ) ) )
            {
                val = 0;
            }
            else if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = ( int64_t )dividend;
            }
            else
            {
                val = ( int64_t )( dividend % divisor );
            }
            break;
        }
        case 0xf:
        {
            uint32_t dividend = ( uint32_t )val1;
            uint32_t divisor = ( uint32_t )val2;
            if( NELUA_UNLIKELY( ( divisor == 0 ) ) )
            {
                val = ( int64_t )( int32_t )dividend;
            }
            else
            {
                val = ( int64_t )( int32_t )( dividend % divisor );
            }
            break;
        }
        default:
        {
            panic("illegal op-32 instruction");
            break;
        }
        }
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )val;
        }
        break;
    }
    case 0x37:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst << 0 ) & 4294963200LL ) << 0 ) ) >> 0 );
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )imm;
        }
        break;
    }
    case 0x17:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst << 0 ) & 4294963200LL ) << 0 ) ) >> 0 );
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )( self->pc + imm );
        }
        break;
    }
    case 0x6f:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( ( ( ( inst >> 11 ) & 1048576 ) | ( ( inst >> 20 ) & 2046 ) ) | ( ( inst >> 9 ) & 2048 ) ) | ( ( inst << 0 ) & 1044480 ) ) << 11 ) ) >> 11 );
        if( NELUA_LIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )( self->pc + 4 );
        }
        self->pc = ( self->pc + imm );
        return;
    }
    case 0x67:
    {
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( inst >> 20 ) & 4095 ) << 20 ) ) >> 20 );
        int64_t pc = ( self->pc + 4 );
        self->pc = ( ( int64_t )( ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ] + imm ) & -2 );
        //printf("jalr: pc = %llx\n", self->pc);
        if( NELUA_UNLIKELY( ( rd != 0 ) ) )
        {
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rd ] = ( uint64_t )pc;
        }
        return;
    }
    case 0x63:
    {
        uint32_t funct3 = ( ( inst >> 12 ) & 7 );
        int64_t imm = ( int64_t )( ( ( int32_t )( ( uint32_t )( int32_t )( ( ( ( ( inst >> 19 ) & 4096 ) | ( ( inst >> 20 ) & 2016 ) ) | ( ( inst >> 7 ) & 30 ) ) | ( ( inst << 4 ) & 2048 ) ) << 19 ) ) >> 19 );
        uint64_t val1 = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs1 ];
        uint64_t val2 = ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ rs2 ];
        bool cond = 0;
        switch( funct3 )
        {
        case 0x0:
        {
            cond = ( val1 == val2 );
            break;
        }
        case 0x1:
        {
            cond = ( val1 != val2 );
            break;
        }
        case 0x4:
        {
            cond = ( ( int64_t )val1 < ( int64_t )val2 );
            break;
        }
        case 0x5:
        {
            cond = ( ( int64_t )val1 >= ( int64_t )val2 );
            break;
        }
        case 0x6:
        {
            cond = ( val1 < val2 );
            break;
        }
        case 0x7:
        {
            cond = ( val1 >= val2 );
            break;
        }
        default:
        {
            panic("illegal branch instruction");
            break;
        }
        }
        if( cond )
        {
            self->pc = ( self->pc + imm );
            return;
        }
        break;
    }
    case 0xf:
    {
        break;
    }
    case 0x73:
    {
        uint32_t funct11 = ( ( inst >> 20 ) & 4095 );
        switch( funct11 )
        {
        case 0x0:
        {
            uint64_t code = get_reg(17);
            ( ( ( nluint64_arr32_cast* )&self->regs )->a ).v[ 10 ] = machine_Machine_handle_syscall( self, code );
            break;
        }
        case 0x1:
        {
            self->exitcode = -1;
            self->running = false;
            break;
        }
        default:
        {
            panic("illegal system instruction");
            break;
        }
        }
        break;
    }
    default:
    {
        panic("illegal instruction");
        break;
    }
    }
    self->pc = ( self->pc + 4 );
}
void machine_Machine_run( machine_Machine_ptr self )
{
    self->running = true;
    while( NELUA_LIKELY( self->running ) )
    {
        uint32_t inst = machine_Machine_fetch( self );

        //unsigned char* p_inst = ( unsigned char* )&inst;
        //printf("pc: 0x%08x, inst: %02x %02x %02x %02x\n", self->pc, p_inst[0], p_inst[1], p_inst[2], p_inst[3]);

        machine_Machine_execute( self, inst );
    }
}
int main( int argc, char** argv )
{
    if( ( argc != 2 ) )
    {
        puts("please supply a RV64I program to run!");
        return EXIT_FAILURE;
    }
    machine_Machine_ptr machine = malloc(sizeof(machine_Machine));
    machine_Machine_loadfile(machine, argv[1]);
    machine_Machine_run(machine);
    exit( ( int )machine->exitcode );
    return EXIT_SUCCESS;
}