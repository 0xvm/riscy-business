/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "riscvm.c" -x none -pipe -fwrapv -fno-strict-aliasing -g -lm -o "riscvm" */
/* Compile hash: 3yRF316SvDmqYnDkveN73j7PiY2f */
/* ------------------------------ DIRECTIVES -------------------------------- */
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
/* Macro used to force inlining a function. */
#ifdef _DEBUG

#define HAS_TRACE
static bool g_trace           = false;
static int  g_trace_calldepth = 0;

#define NELUA_INLINE
#define trace(...)                                      \
    do                                                  \
    {                                                   \
        if (g_trace)                                    \
        {                                               \
            for (int i = 0; i < g_trace_calldepth; i++) \
            {                                           \
                printf("  ");                           \
            }                                           \
            printf("[trace] " __VA_ARGS__);             \
        }                                               \
    } while (0)

#else

#define trace(...)

#ifdef __GNUC__
#define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
#define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
#define NELUA_INLINE inline
#else
#define NELUA_INLINE
#endif

#endif // _DEBUG
#include <stddef.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
#define NELUA_EXTERN extern "C"
#else
#define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
#endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
#define NELUA_UBSAN_UNREACHABLE()                \
    {                                            \
        if (&__ubsan_handle_builtin_unreachable) \
            __builtin_unreachable();             \
    }
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
#define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
#define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
#define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
#define NELUA_NORETURN __declspec(noreturn)
#else
#define NELUA_NORETURN
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
#define NELUA_MAYALIAS __attribute__((may_alias))
#else
#define NELUA_MAYALIAS
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
#define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
#define NELUA_LIKELY(x) (x)
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
#define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
#define NELUA_UNLIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
#define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#define NELUA_NOINLINE __declspec(noinline)
#else
#define NELUA_NOINLINE
#endif
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct machine_Machine machine_Machine;
typedef machine_Machine*       machine_Machine_ptr;
struct machine_Machine
{
    bool     running;
    int64_t  pc;
    uint64_t regs[32];
    int64_t  exitcode;
};
typedef union
{
    struct
    {
        uint32_t opcode : 7;
        uint32_t        : 25;
    };

    struct
    {
        uint32_t opcode : 7;
        uint32_t rd     : 5;
        uint32_t funct3 : 3;
        uint32_t rs1    : 5;
        uint32_t rs2    : 5;
        uint32_t funct7 : 7;
    } rtype;

    struct
    {
        uint32_t opcode : 7;
        uint32_t rd     : 5;
        uint32_t funct3 : 3;
        uint32_t rs1    : 5;
        uint32_t imm    : 12;
    } itype;

    struct
    {
        uint32_t opcode : 7;
        uint32_t rd     : 5;
        uint32_t funct3 : 3;
        uint32_t rs1    : 5;
        uint32_t rs2    : 5;
        uint32_t shamt  : 1;
        uint32_t imm    : 6;
    } iwtype;

    struct
    {
        uint32_t opcode : 7;
        uint32_t rd     : 5;
        uint32_t imm    : 20;
    } utype;

    struct
    {
        uint32_t opcode : 7;
        uint32_t rd     : 5;
        uint32_t imm    : 20;
    } ujtype;

    struct
    {
        uint32_t opcode : 7;
        uint32_t imm5   : 5;
        uint32_t funct3 : 3;
        uint32_t rs1    : 5;
        uint32_t rs2    : 5;
        uint32_t imm7   : 7;
    } stype;

    struct
    {
        uint32_t opcode : 7;
        uint32_t imm5   : 5;
        uint32_t funct3 : 3;
        uint32_t rs1    : 5;
        uint32_t rs2    : 5;
        uint32_t imm7   : 7;
    } sbtype;

    int16_t  chunks16[2];
    uint32_t bits;
} Instruction;

typedef enum
{
    insn_rtype  = 0b0110011,
    insn_itype  = 0b0010011,
    insn_stype  = 0b0100011,
    insn_utype  = 0b0110111,
    insn_ujtype = 0b1101111,
    insn_sbtype = 0b1100011,
    insn_istype = 0b0000011,
} InstructionType;

static NELUA_INLINE uint32_t machine_Machine_fetch(machine_Machine_ptr self);
static NELUA_INLINE int8_t   machine_Machine_read_int8(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE int16_t  machine_Machine_read_int16(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE int32_t  machine_Machine_read_int32(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE int64_t  machine_Machine_read_int64(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE uint8_t  machine_Machine_read_uint8(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE uint16_t machine_Machine_read_uint16(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE uint32_t machine_Machine_read_uint32(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE void*    machine_Machine_getptr(machine_Machine_ptr self, uint64_t addr);
static NELUA_INLINE void machine_Machine_write_uint8(machine_Machine_ptr self, uint64_t addr, uint8_t val);
static NELUA_INLINE void machine_Machine_write_uint16(machine_Machine_ptr self, uint64_t addr, uint16_t val);
static NELUA_INLINE void machine_Machine_write_uint32(machine_Machine_ptr self, uint64_t addr, uint32_t val);
static NELUA_INLINE void machine_Machine_write_uint64(machine_Machine_ptr self, uint64_t addr, uint64_t val);
static uint64_t          machine_Machine_handle_syscall(machine_Machine_ptr self, uint64_t code);
static NELUA_INLINE void machine_Machine_execute(machine_Machine_ptr self, Instruction inst);
static NELUA_INLINE int64_t  machine_Machine_shl_nlint64(int64_t a, int64_t b);
static NELUA_INLINE int64_t  machine_Machine_shr_nlint64(int64_t a, int64_t b);
static NELUA_INLINE int64_t  machine_Machine_asr_nlint64(int64_t a, int64_t b);
static NELUA_INLINE __int128 machine_Machine_shr_nlint128(__int128 a, __int128 b);
static NELUA_NOINLINE void   machine_Machine_run(machine_Machine_ptr self);

// Reference: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc
typedef enum
{
    reg_zero, // always zero
    reg_ra,   // return address
    reg_sp,   // stack pointer
    reg_gp,   // global pointer
    reg_tp,   // thread pointer
    reg_t0,
    reg_t1,
    reg_t2,
    reg_s0,
    reg_s1,
    reg_a0,
    reg_a1,
    reg_a2,
    reg_a3,
    reg_a4,
    reg_a5,
    reg_a6,
    reg_a7,
    reg_s2,
    reg_s3,
    reg_s4,
    reg_s5,
    reg_s6,
    reg_s7,
    reg_s8,
    reg_s9,
    reg_s10,
    reg_s11,
    reg_t3,
    reg_t4,
    reg_t5,
    reg_t6,
} RegIndex;

#pragma section(".vmcode", read, write)
__declspec(align(4096)) uint8_t g_code[0x10000];

#pragma section(".vmstack", read, write)
__declspec(align(4096)) uint8_t g_stack[0x10000];

#define reg_read(idx)         (int64_t) self->regs[idx]
#define reg_write(idx, value) self->regs[idx] = value

/* ------------------------------ DEFINITIONS ------------------------------- */
#define panic(...)           \
    do                       \
    {                        \
        printf(__VA_ARGS__); \
        __debugbreak();      \
    } while (0)
void machine_Machine_loadfile(machine_Machine_ptr self, const char* filename)
{
    FILE* fp = fopen(filename, "rb");
    if ((!(fp != NULL)))
    {
        puts("failed to open file");
    }
    fseek(fp, 0, SEEK_END);
    long size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    if (size > sizeof(g_code))
    {
        puts("loaded code too big!");
        exit(EXIT_FAILURE);
    }
    fread(g_code, size, 1, fp);
    fclose(fp);
    reg_write(reg_sp, (uint64_t)&g_stack[sizeof(g_stack) - 0x10]);
    self->pc = (int64_t)g_code;
}
uint32_t machine_Machine_fetch(machine_Machine_ptr self)
{
    uint32_t data;
    memcpy(&data, (const void*)self->pc, sizeof(data));
    return data;
}
int8_t machine_Machine_read_int8(machine_Machine_ptr self, uint64_t addr)
{
    int8_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
int16_t machine_Machine_read_int16(machine_Machine_ptr self, uint64_t addr)
{
    int16_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
int32_t machine_Machine_read_int32(machine_Machine_ptr self, uint64_t addr)
{
    int32_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
int64_t machine_Machine_read_int64(machine_Machine_ptr self, uint64_t addr)
{
    int64_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
uint8_t machine_Machine_read_uint8(machine_Machine_ptr self, uint64_t addr)
{
    uint8_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
uint16_t machine_Machine_read_uint16(machine_Machine_ptr self, uint64_t addr)
{
    uint16_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
uint32_t machine_Machine_read_uint32(machine_Machine_ptr self, uint64_t addr)
{
    uint32_t data;
    memcpy(&data, (const void*)addr, sizeof(data));
    return data;
}
void* machine_Machine_getptr(machine_Machine_ptr self, uint64_t addr)
{
    return (void*)addr;
}
void machine_Machine_write_uint8(machine_Machine_ptr self, uint64_t addr, uint8_t val)
{
    memcpy((void*)addr, &val, sizeof(val));
}
void machine_Machine_write_uint16(machine_Machine_ptr self, uint64_t addr, uint16_t val)
{
    memcpy((void*)addr, &val, sizeof(val));
}
void machine_Machine_write_uint32(machine_Machine_ptr self, uint64_t addr, uint32_t val)
{
    memcpy((void*)addr, &val, sizeof(val));
}
void machine_Machine_write_uint64(machine_Machine_ptr self, uint64_t addr, uint64_t val)
{
    memcpy((void*)addr, &val, sizeof(val));
}

NELUA_INLINE int32_t bit_signer(uint32_t field, uint32_t size)
{
    return (field & (1U << (size - 1))) ? (int32_t)(field | (0xFFFFFFFFU << size)) : (int32_t)field;
}

NELUA_INLINE uint32_t syscall_0_stub(uint32_t id)
{
    register void* a1 asm("r10");
    void*          a2;
    register void* a3 asm("r8");
    register void* a4 asm("r9");

    void*          unused_output;
    register void* unused_output2 asm("r11");

    uint32_t status;
    asm volatile("syscall\n"
                 : "=a"(status), "=r"(a1), "=d"(a2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_1_stub(uint32_t id, uint64_t _1)
{
    register uint64_t a1 asm("r10") = _1;
    void*             a2;
    register void*    a3 asm("r8");
    register void*    a4 asm("r9");

    void*          unused_output;
    register void* unused_output2 asm("r11");

    uint32_t status;
    asm volatile("syscall\n"
                 : "=a"(status), "=r"(a1), "=d"(a2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_2_stub(uint32_t id, uint64_t _1, uint64_t _2)
{
    register uint64_t a1 asm("r10") = _1;
    register void*    a3 asm("r8");
    register void*    a4 asm("r9");

    void*          unused_output;
    register void* unused_output2 asm("r11");

    uint32_t status;
    asm volatile("syscall\n"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1), "d"(_2)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_3_stub(uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register void*    a4 asm("r9");

    void*          unused_output;
    register void* unused_output2 asm("r11");

    uint32_t status;
    asm volatile("syscall\n"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1), "d"(_2), "r"(a3)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_4_stub(uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*          unused_output;
    register void* unused_output2 asm("r11");

    uint32_t status;
    asm volatile("syscall\n"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_5_stub(uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*          unused_output;
    register void* unused_output2 asm("r11");

    uint32_t status;
    asm volatile("sub $48, %%rsp\n"
                 "movq %[a5], 40(%%rsp)\n"
                 "syscall\n"
                 "add $48, %%rsp"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"((void*)(_5))
                 : "cc");
    return status;
}

NELUA_INLINE uint32_t
syscall_6_stub(uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile("sub $64, %%rsp\n"
                 "movq %[a5], 40(%%rsp)\n"
                 "movq %[a6], 48(%%rsp)\n"
                 "syscall\n"
                 "add $64, %%rsp"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"(_5), [a6] "re"(_6)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_7_stub(
    uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile("sub $64, %%rsp\n"
                 "movq %[a5], 40(%%rsp)\n"
                 "movq %[a6], 48(%%rsp)\n"
                 "movq %[a7], 56(%%rsp)\n"
                 "syscall\n"
                 "add $64, %%rsp"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"(_5), [a6] "re"(_6), [a7] "re"(_7)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_8_stub(
    uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile(
        "sub $80, %%rsp\n"
        "movq %[a5], 40(%%rsp)\n"
        "movq %[a6], 48(%%rsp)\n"
        "movq %[a7], 56(%%rsp)\n"
        "movq %[a8], 64(%%rsp)\n"
        "syscall\n"
        "add $80, %%rsp"
        : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
        : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"(_5), [a6] "re"(_6), [a7] "re"(_7), [a8] "re"(_8)
        : "memory", "cc"
    );
    return status;
}

NELUA_INLINE uint32_t syscall_9_stub(
    uint32_t id, uint64_t _1, uint64_t _2, uint64_t _3, uint64_t _4, uint64_t _5, uint64_t _6, uint64_t _7, uint64_t _8, uint64_t _9
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile(
        "sub $80, %%rsp\n"
        "movq %[a5], 40(%%rsp)\n"
        "movq %[a6], 48(%%rsp)\n"
        "movq %[a7], 56(%%rsp)\n"
        "movq %[a8], 64(%%rsp)\n"
        "movq %[a9], 72(%%rsp)\n"
        "syscall\n"
        "add $80, %%rsp"
        : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
        : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"(_5), [a6] "re"(_6), [a7] "re"(_7), [a8] "re"(_8), [a9] "re"(_9)
        : "memory", "cc"
    );
    return status;
}

NELUA_INLINE uint32_t syscall_10_stub(
    uint32_t id,
    uint64_t _1,
    uint64_t _2,
    uint64_t _3,
    uint64_t _4,
    uint64_t _5,
    uint64_t _6,
    uint64_t _7,
    uint64_t _8,
    uint64_t _9,
    uint64_t _10
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile(
        "sub $96, %%rsp\n"
        "movq %[a5], 40(%%rsp)\n"
        "movq %[a6], 48(%%rsp)\n"
        "movq %[a7], 56(%%rsp)\n"
        "movq %[a8], 64(%%rsp)\n"
        "movq %[a9], 72(%%rsp)\n"
        "movq %[a10], 80(%%rsp)\n"
        "syscall\n"
        "add $96, %%rsp"
        : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
        : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"(_5), [a6] "re"(_6), [a7] "re"(_7), [a8] "re"(_8), [a9] "re"(_9), [a10] "re"(_10)
        : "memory", "cc"
    );
    return status;
}

NELUA_INLINE uint32_t syscall_11_stub(
    uint32_t id,
    uint64_t _1,
    uint64_t _2,
    uint64_t _3,
    uint64_t _4,
    uint64_t _5,
    uint64_t _6,
    uint64_t _7,
    uint64_t _8,
    uint64_t _9,
    uint64_t _10,
    uint64_t _11
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile(
        "sub $96, %%rsp\n"
        "movq %[a5], 40(%%rsp)\n"
        "movq %[a6], 48(%%rsp)\n"
        "movq %[a7], 56(%%rsp)\n"
        "movq %[a8], 64(%%rsp)\n"
        "movq %[a9], 72(%%rsp)\n"
        "movq %[a10], 80(%%rsp)\n"
        "movq %[a11], 88(%%rsp)\n"
        "syscall\n"
        "add $96, %%rsp"
        : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
        : "a"(id), "r"(a1), "d"(_2), "r"(a3), "r"(a4), [a5] "re"(_5), [a6] "re"(_6), [a7] "re"(_7), [a8] "re"(_8), [a9] "re"(_9), [a10] "re"(_10), [a11] "re"(_11)
        : "memory", "cc"
    );
    return status;
}

NELUA_INLINE uint32_t syscall_12_stub(
    uint32_t id,
    uint64_t _1,
    uint64_t _2,
    uint64_t _3,
    uint64_t _4,
    uint64_t _5,
    uint64_t _6,
    uint64_t _7,
    uint64_t _8,
    uint64_t _9,
    uint64_t _10,
    uint64_t _11,
    uint64_t _12
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile("sub $112, %%rsp\n"
                 "movq %[a5], 40(%%rsp)\n"
                 "movq %[a6], 48(%%rsp)\n"
                 "movq %[a7], 56(%%rsp)\n"
                 "movq %[a8], 64(%%rsp)\n"
                 "movq %[a9], 72(%%rsp)\n"
                 "movq %[a10], 80(%%rsp)\n"
                 "movq %[a11], 88(%%rsp)\n"
                 "movq %[a12], 96(%%rsp)\n"
                 "syscall\n"
                 "add $112, %%rsp"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id),
                   "r"(a1),
                   "d"(_2),
                   "r"(a3),
                   "r"(a4),
                   [a5] "re"(_5),
                   [a6] "re"(_6),
                   [a7] "re"(_7),
                   [a8] "re"(_8),
                   [a9] "re"(_9),
                   [a10] "re"(_10),
                   [a11] "re"(_11),
                   [a12] "re"(_12)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint32_t syscall_13_stub(
    uint32_t id,
    uint64_t _1,
    uint64_t _2,
    uint64_t _3,
    uint64_t _4,
    uint64_t _5,
    uint64_t _6,
    uint64_t _7,
    uint64_t _8,
    uint64_t _9,
    uint64_t _10,
    uint64_t _11,
    uint64_t _12,
    uint64_t _13
)
{
    register uint64_t a1 asm("r10") = _1;
    register uint64_t a3 asm("r8")  = _3;
    register uint64_t a4 asm("r9")  = _4;

    void*             unused_output;
    register uint64_t unused_output2 asm("r11");

    uint32_t status;
    asm volatile("sub $112, %%rsp\n"
                 "movq %[a5], 40(%%rsp)\n"
                 "movq %[a6], 48(%%rsp)\n"
                 "movq %[a7], 56(%%rsp)\n"
                 "movq %[a8], 64(%%rsp)\n"
                 "movq %[a9], 72(%%rsp)\n"
                 "movq %[a10], 80(%%rsp)\n"
                 "movq %[a11], 88(%%rsp)\n"
                 "movq %[a12], 96(%%rsp)\n"
                 "movq %[a13], 104(%%rsp)\n"
                 "syscall\n"
                 "add $112, %%rsp"
                 : "=a"(status), "=r"(a1), "=d"(_2), "=r"(a3), "=r"(a4), "=c"(unused_output), "=r"(unused_output2)
                 : "a"(id),
                   "r"(a1),
                   "d"(_2),
                   "r"(a3),
                   "r"(a4),
                   [a5] "re"(_5),
                   [a6] "re"(_6),
                   [a7] "re"(_7),
                   [a8] "re"(_8),
                   [a9] "re"(_9),
                   [a10] "re"(_10),
                   [a11] "re"(_11),
                   [a12] "re"(_12),
                   [a13] "re"(_13)
                 : "memory", "cc");
    return status;
}

NELUA_INLINE uint64_t machine_Machine_handle_syscall(machine_Machine_ptr self, uint64_t code)
{
    trace("syscall %llu\n", code);
    switch (code)
    {
    case 10000:
    {
        self->running  = false;
        self->exitcode = reg_read(reg_a0);
        break;
    }
    case 10001:
    {
        panic("aborted!");
        break;
    }
    case 10006:
    {
        void* src  = machine_Machine_getptr(self, reg_read(reg_a0));
        void* dest = machine_Machine_getptr(self, reg_read(reg_a1));
        void* res  = memcpy(dest, src, (size_t)reg_read(reg_a2));
        return (uint64_t)res;
    }
    case 10007:
    {
        void* dest = machine_Machine_getptr(self, reg_read(reg_a0));
        void* res  = memset(dest, (int)reg_read(reg_a1), (size_t)reg_read(reg_a2));
        return (uint64_t)res;
    }
    case 10008:
    {
        void* src  = machine_Machine_getptr(self, reg_read(reg_a0));
        void* dest = machine_Machine_getptr(self, reg_read(reg_a1));
        void* res  = memmove(dest, src, (size_t)reg_read(reg_a2));
        return (uint64_t)res;
    }
    case 10009:
    {
        void* src1 = machine_Machine_getptr(self, reg_read(reg_a0));
        void* src2 = machine_Machine_getptr(self, reg_read(reg_a1));
        return (uint64_t)memcmp(src1, src2, (size_t)reg_read(reg_a2));
    }
    case 10101:
    {
        char* s = (char*)machine_Machine_getptr(self, reg_read(reg_a0));
        if (s != NULL)
        {
            puts(s);
        }
        break;
    }
    case 10102:
    {
        printf("value: %lli\n", reg_read(reg_a0));
        break;
    }
    case 20000:
    {
        uint32_t  id    = (uint32_t)reg_read(reg_a0);
        uint64_t* args  = (uint64_t*)machine_Machine_getptr(self, reg_read(reg_a1));
        size_t    nargs = (size_t)reg_read(reg_a2);
        switch (nargs)
        {
        case 0:
        {
            return (uint64_t)syscall_0_stub(id);
        }
        case 1:
        {
            return (uint64_t)syscall_1_stub(id, args[0]);
        }
        case 2:
        {
            return (uint64_t)syscall_2_stub(id, args[0], args[1]);
        }
        case 3:
        {
            return (uint64_t)syscall_3_stub(id, args[0], args[1], args[2]);
        }
        case 4:
        {
            return (uint64_t)syscall_4_stub(id, args[0], args[1], args[2], args[3]);
        }
        case 5:
        {
            return (uint64_t)syscall_5_stub(id, args[0], args[1], args[2], args[3], args[4]);
        }
        case 6:
        {
            return (uint64_t)syscall_6_stub(id, args[0], args[1], args[2], args[3], args[4], args[5]);
        }
        case 7:
        {
            return (uint64_t)syscall_7_stub(id, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        case 8:
        {
            return (uint64_t
            )syscall_8_stub(id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        }
        case 9:
        {
            return (uint64_t
            )syscall_9_stub(id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        }
        case 10:
        {
            return (uint64_t)syscall_10_stub(
                id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]
            );
        }
        case 11:
        {
            return (uint64_t)syscall_11_stub(
                id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]
            );
        }
        case 12:
        {
            return (uint64_t)syscall_12_stub(
                id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]
            );
        }
        case 13:
        {
            return (uint64_t)syscall_13_stub(
                id,
                args[0],
                args[1],
                args[2],
                args[3],
                args[4],
                args[5],
                args[6],
                args[7],
                args[8],
                args[9],
                args[10],
                args[11],
                args[12]
            );
        }
        default:
        {
            panic("too many arguments for windows syscall");
            break;
        }
        }
    }
    default:
    {
        panic("illegal system call %llu (0x%llX)\n", code, code);
        break;
    }
    }
    return 0U;
}
int64_t machine_Machine_shl_nlint64(int64_t a, int64_t b)
{
    if (NELUA_LIKELY(b >= 0 && b < 64))
    {
        return ((uint64_t)a) << b;
    }
    else if (NELUA_UNLIKELY(b < 0 && b > -64))
    {
        return (uint64_t)a >> -b;
    }
    else
    {
        return 0;
    }
}
int64_t machine_Machine_shr_nlint64(int64_t a, int64_t b)
{
    if (NELUA_LIKELY(b >= 0 && b < 64))
    {
        return (uint64_t)a >> b;
    }
    else if (NELUA_UNLIKELY(b < 0 && b > -64))
    {
        return (uint64_t)a << -b;
    }
    else
    {
        return 0;
    }
}
int64_t machine_Machine_asr_nlint64(int64_t a, int64_t b)
{
    if (NELUA_LIKELY(b >= 0 && b < 64))
    {
        return a >> b;
    }
    else if (NELUA_UNLIKELY(b >= 64))
    {
        return a < 0 ? -1 : 0;
    }
    else if (NELUA_UNLIKELY(b < 0 && b > -64))
    {
        return a << -b;
    }
    else
    {
        return 0;
    }
}
__int128 machine_Machine_shr_nlint128(__int128 a, __int128 b)
{
    if (NELUA_LIKELY(b >= 0 && b < 128))
    {
        return (unsigned __int128)a >> b;
    }
    else if (NELUA_UNLIKELY(b < 0 && b > -128))
    {
        return (unsigned __int128)a << -b;
    }
    else
    {
        return 0;
    }
}
void machine_Machine_execute(machine_Machine_ptr self, Instruction inst)
{
    // uint32_t opcode = ((inst.bits >> 0) & 0b1111111);
    RegIndex rd  = ((inst.bits >> 7) & 0b11111);
    RegIndex rs1 = ((inst.bits >> 15) & 0b11111);
    RegIndex rs2 = ((inst.bits >> 20) & 0b11111);
    switch (inst.opcode)
    {
    case 0b0000011: // load memory
    {
        uint64_t addr = reg_read(inst.itype.rs1) + inst.itype.imm;
        int64_t  val  = 0;
        switch (inst.itype.funct3)
        {
        case 0b000: // lb
        {
            val = machine_Machine_read_int8(self, addr);
            break;
        }
        case 0b001: // lh
        {
            val = machine_Machine_read_int16(self, addr);
            break;
        }
        case 0b010: // lw
        {
            val = machine_Machine_read_int32(self, addr);
            break;
        }
        case 0b011: // ld
        {
            val = machine_Machine_read_int64(self, addr);
            break;
        }
        case 0b100: // lbu
        {
            val = machine_Machine_read_uint8(self, addr);
            break;
        }
        case 0b101: // lhu
        {
            val = machine_Machine_read_uint16(self, addr);
            break;
        }
        case 0b110: // lwu
        {
            val = machine_Machine_read_uint32(self, addr);
            break;
        }
        default:
        {
            panic("illegal load instruction");
            break;
        }
        }
        if (NELUA_LIKELY((inst.itype.rd != reg_zero)))
        {
            reg_write(inst.itype.rd, (uint64_t)val);
        }
        break;
    }
    case 0b100011: // store memory
    {
        int32_t  imm  = bit_signer((inst.stype.imm7 << 5) | inst.stype.imm5, 12);
        uint64_t addr = reg_read(inst.stype.rs1) + imm;
        uint64_t val  = reg_read(inst.stype.rs2);
        switch (inst.stype.funct3)
        {
        case 0x0:
        {
            machine_Machine_write_uint8(self, addr, (uint8_t)val);
            break;
        }
        case 0x1:
        {
            machine_Machine_write_uint16(self, addr, (uint16_t)val);
            break;
        }
        case 0x2:
        {
            machine_Machine_write_uint32(self, addr, (uint32_t)val);
            break;
        }
        case 0x3:
        {
            machine_Machine_write_uint64(self, addr, val);
            break;
        }
        default:
        {
            panic("illegal store instruction");
            break;
        }
        }
        break;
    }
    case 0b0010011: // arithmetic
    {
        int64_t imm = bit_signer(inst.itype.imm, 12);
        int64_t val = reg_read(inst.itype.rs1);
        switch (inst.itype.funct3)
        {
        case 0b000: // addi
        {
            val = (val + imm);
            break;
        }
        case 0b001: // slli
        {
            val = machine_Machine_shl_nlint64(val, inst.iwtype.rs2);
            break;
        }
        case 0b010: // slti
        {
            if ((val < imm))
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0b011: // sltiu
        {
            if (((uint64_t)val < (uint64_t)imm))
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0b100: // xori
        {
            val = (val ^ imm);
            break;
        }
        case 0b101: // srli
        {
            if (inst.iwtype.shamt)
            {
                val = machine_Machine_asr_nlint64(val, inst.iwtype.rs2);
            }
            else
            {
                val = machine_Machine_shr_nlint64(val, inst.iwtype.rs2);
            }
            break;
        }
        case 0b110: // ori
        {
            val = (val | imm);
            break;
        }
        case 0b111: // andi
        {
            val = (val & imm);
            break;
        }
        default:
        {
            panic("illegal op-imm instruction");
            break;
        }
        }
        if (NELUA_LIKELY(inst.itype.rd != reg_zero))
        {
            reg_write(inst.itype.rd, val);
        }
        break;
    }
    case 0b0011011: // rv64i arithmetic
    {
        int64_t imm = bit_signer(inst.itype.imm, 12);
        int64_t val = reg_read(inst.itype.rs1);
        switch (inst.itype.funct3)
        {
        case 0b000:
        {
            val = (int64_t)(int32_t)(val + imm);
            break;
        }
        case 0b001:
        {
            val = (int64_t)(int32_t)machine_Machine_shl_nlint64(val, imm);
            break;
        }
        case 0b101:
        {
            if (inst.iwtype.shamt)
            {
                val = (int64_t)(int32_t)machine_Machine_asr_nlint64(val, inst.iwtype.rs2);
            }
            else
            {
                val = (int64_t)(int32_t)machine_Machine_shr_nlint64(val, inst.iwtype.rs2);
            }
            break;
        }
        default:
        {
            panic("illegal op-imm-32 instruction");
            break;
        }
        }
        if (NELUA_LIKELY(inst.itype.rd != reg_zero))
        {
            reg_write(inst.itype.rd, val);
        }
        break;
    }
    case 0b0110011: // R type
    {
        int64_t val1 = reg_read(inst.rtype.rs1);
        int64_t val2 = reg_read(inst.rtype.rs2);
        int64_t val  = 0;
        switch ((inst.rtype.funct7 << 3) | inst.rtype.funct3)
        {
        case 0x0:
        {
            val = (val1 + val2);
            break;
        }
        case 0x100:
        {
            val = (val1 - val2);
            break;
        }
        case 0x1:
        {
            val = machine_Machine_shl_nlint64(val1, (val2 & 0x1f));
            break;
        }
        case 0x2:
        {
            if ((val1 < val2))
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x3:
        {
            if (((uint64_t)val1 < (uint64_t)val2))
            {
                val = 1;
            }
            else
            {
                val = 0;
            }
            break;
        }
        case 0x4:
        {
            val = (val1 ^ val2);
            break;
        }
        case 0x5:
        {
            val = machine_Machine_shr_nlint64(val1, (val2 & 0x1f));
            break;
        }
        case 0x105:
        {
            val = machine_Machine_asr_nlint64(val1, (val2 & 0x1f));
            break;
        }
        case 0x6:
        {
            val = (val1 | val2);
            break;
        }
        case 0x7:
        {
            val = (val1 & val2);
            break;
        }
        case 0x8:
        {
            val = (val1 * val2);
            break;
        }
        case 0x9:
        {
            val = (int64_t)(uint64_t)machine_Machine_shr_nlint128(((__int128)val1 * (__int128)val2), 64);
            break;
        }
        case 0xa:
        {
            val = (int64_t)(uint64_t
            )machine_Machine_shr_nlint128(((__int128)val1 * (__int128)(uint64_t)val2), 64);
            break;
        }
        case 0xb:
        {
            val = (int64_t)(uint64_t
            )machine_Machine_shr_nlint128(((__int128)(uint64_t)val1 * (__int128)(uint64_t)val2), 64);
            break;
        }
        case 0xc:
        {
            int64_t dividend = val1;
            int64_t divisor  = val2;
            if (NELUA_UNLIKELY(((dividend == (-9223372036854775807LL - 1)) && (divisor == -1))))
            {
                val = (-9223372036854775807LL - 1);
            }
            else if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = -1;
            }
            else
            {
                val = (dividend / divisor);
            }
            break;
        }
        case 0xd:
        {
            uint64_t dividend = (uint64_t)val1;
            uint64_t divisor  = (uint64_t)val2;
            if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = -1;
            }
            else
            {
                val = (int64_t)(dividend / divisor);
            }
            break;
        }
        case 0xe:
        {
            int64_t dividend = val1;
            int64_t divisor  = val2;
            if (NELUA_UNLIKELY(((dividend == (-9223372036854775807LL - 1)) && (divisor == -1))))
            {
                val = 0;
            }
            else if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = dividend;
            }
            else
            {
                val = (dividend % divisor);
            }
            break;
        }
        case 0xf:
        {
            uint64_t dividend = (uint64_t)val1;
            uint64_t divisor  = (uint64_t)val2;
            if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = (int64_t)dividend;
            }
            else
            {
                val = (int64_t)(dividend % divisor);
            }
            break;
        }
        default:
        {
            panic("illegal op instruction");
            break;
        }
        }
        if (NELUA_LIKELY(inst.rtype.rd != reg_zero))
        {
            reg_write(inst.rtype.rd, val);
        }
        break;
    }
    case 0x3b:
    {
        int64_t val1 = reg_read(inst.rtype.rs1);
        int64_t val2 = reg_read(inst.rtype.rs2);
        int64_t val;
        switch ((inst.rtype.funct7 << 3) | inst.rtype.funct3)
        {
        case 0x0:
        {
            val = (int64_t)(int32_t)(val1 + val2);
            break;
        }
        case 0x100:
        {
            val = (int64_t)(int32_t)(val1 - val2);
            break;
        }
        case 0x1:
        {
            val = (int64_t)(int32_t)machine_Machine_shl_nlint64(val1, (val2 & 0x1f));
            break;
        }
        case 0x5:
        {
            val = (int64_t)(int32_t)machine_Machine_shr_nlint64(val1, (val2 & 0x1f));
            break;
        }
        case 0x105:
        {
            val = (int64_t)(int32_t)machine_Machine_asr_nlint64(val1, (val2 & 0x1f));
            break;
        }
        case 0x8:
        {
            val = (int64_t)((int32_t)val1 * (int32_t)val2);
            break;
        }
        case 0xc:
        {
            int32_t dividend = (int32_t)val1;
            int32_t divisor  = (int32_t)val2;
            if (NELUA_UNLIKELY(((dividend == (-2147483647 - 1)) && (divisor == -1))))
            {
                val = -2147483648LL;
            }
            else if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = -1;
            }
            else
            {
                val = (int64_t)(dividend / divisor);
            }
            break;
        }
        case 0xd:
        {
            uint32_t dividend = (uint32_t)val1;
            uint32_t divisor  = (uint32_t)val2;
            if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = -1;
            }
            else
            {
                val = (int64_t)(int32_t)(dividend / divisor);
            }
            break;
        }
        case 0xe:
        {
            int32_t dividend = (int32_t)val1;
            int32_t divisor  = (int32_t)val2;
            if (NELUA_UNLIKELY(((dividend == (-2147483647 - 1)) && (divisor == -1))))
            {
                val = 0;
            }
            else if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = (int64_t)dividend;
            }
            else
            {
                val = (int64_t)(dividend % divisor);
            }
            break;
        }
        case 0xf:
        {
            uint32_t dividend = (uint32_t)val1;
            uint32_t divisor  = (uint32_t)val2;
            if (NELUA_UNLIKELY((divisor == 0)))
            {
                val = (int64_t)(int32_t)dividend;
            }
            else
            {
                val = (int64_t)(int32_t)(dividend % divisor);
            }
            break;
        }
        default:
        {
            panic("illegal op-32 instruction");
            break;
        }
        }
        if (NELUA_LIKELY(inst.rtype.rd != reg_zero))
        {
            reg_write(inst.rtype.rd, val);
        }
        break;
    }
    case 0x37:
    {
        int64_t imm = (int64_t)(((int32_t)((uint32_t)(int32_t)((inst.bits << 0) & 4294963200LL) << 0)) >> 0);
        if (NELUA_LIKELY(inst.utype.rd != reg_zero))
        {
            reg_write(inst.utype.rd, imm);
        }
        break;
    }
    case 0x17:
    {
        int64_t imm = (int64_t)(((int32_t)((uint32_t)(int32_t)((inst.bits << 0) & 4294963200LL) << 0)) >> 0);
        if (NELUA_LIKELY((rd != reg_zero)))
        {
            reg_write(rd, self->pc + imm);
        }
        break;
    }
    case 0b1101111: // jal (call)
    {
#ifdef HAS_TRACE
        if (rd == reg_ra)
        {
            trace("^^ call\n");
            g_trace_calldepth++;
        }
        else if (rd != reg_zero)
            trace("sus link register (jal): %d\n", rd);
#endif // HAS_TRACE

        int64_t imm = (int64_t
        )(((int32_t
          )((uint32_t)(int32_t
            )(((((inst.bits >> 11) & 1048576) | ((inst.bits >> 20) & 2046)) | ((inst.bits >> 9) & 2048))
              | ((inst.bits << 0) & 1044480))
            << 11))
          >> 11);
        if (NELUA_LIKELY((rd != reg_zero)))
        {
            reg_write(rd, self->pc + 4);
        }
        self->pc = (self->pc + imm);
        return;
    }
    case 0b1100111: // jalr (ret)
    {
#ifdef HAS_TRACE
        if (rs1 == reg_ra)
        {
            trace("^^ return\n");
            g_trace_calldepth--;
        }
        else
            trace("sus link register (ret): %d\n", rs1);
#endif // HAS_TRACE

        int64_t imm = (int64_t)(((int32_t)((uint32_t)(int32_t)((inst.bits >> 20) & 4095) << 20)) >> 20);
        int64_t pc  = (self->pc + 4);
        self->pc    = ((int64_t)(reg_read(rs1) + imm) & -2);

        if (NELUA_UNLIKELY((rd != reg_zero)))
        {
            reg_write(rd, pc);
        }
        return;
    }
    case 0b1100011: // conditional branch
    {
        trace("^^ conditional branch\n");
        uint32_t funct3 = ((inst.bits >> 12) & 7);
        int64_t  imm    = (int64_t
        )(((int32_t
          )((uint32_t)(int32_t
            )(((((inst.bits >> 19) & 4096) | ((inst.bits >> 20) & 2016)) | ((inst.bits >> 7) & 30))
              | ((inst.bits << 4) & 2048))
            << 19))
          >> 19);
        uint64_t val1   = reg_read(rs1);
        uint64_t val2   = reg_read(rs2);
        bool     cond   = 0;
        switch (funct3)
        {
        case 0b000: // beq
        {
            cond = (val1 == val2);
            break;
        }
        case 0b001: // bne
        {
            cond = (val1 != val2);
            break;
        }
        case 0b100: // blt
        {
            cond = ((int64_t)val1 < (int64_t)val2);
            break;
        }
        case 0b101: // bge
        {
            cond = ((int64_t)val1 >= (int64_t)val2);
            break;
        }
        case 0b110: // bltu
        {
            cond = (val1 < val2);
            break;
        }
        case 0b111: // bgeu
        {
            cond = (val1 >= val2);
            break;
        }
        default:
        {
            panic("illegal branch instruction");
            break;
        }
        }
        if (cond)
        {
            self->pc = (self->pc + imm);
            return;
        }
        break;
    }
    case 0xf:
    {
        break;
    }
    case 0x73:
    {
        uint32_t funct11 = ((inst.bits >> 20) & 4095);
        switch (funct11)
        {
        case 0x0:
        {
            uint64_t code = reg_read(reg_a7);
            reg_write(reg_a0, machine_Machine_handle_syscall(self, code));
            break;
        }
        case 0x1:
        {
            self->exitcode = -1;
            self->running  = false;
            break;
        }
        default:
        {
            panic("illegal system instruction");
            break;
        }
        }
        break;
    }
    default:
    {
        panic("illegal instruction");
        break;
    }
    }
    self->pc = (self->pc + 4);
}
void machine_Machine_run(machine_Machine_ptr self)
{
    self->running = true;
    while (NELUA_LIKELY(self->running))
    {
        Instruction inst = (Instruction)machine_Machine_fetch(self);

        unsigned char* p_inst = (unsigned char*)&inst.bits;
        (void)p_inst;
        trace("pc: 0x%llx, inst: %02x %02x %02x %02x\n", self->pc, p_inst[0], p_inst[1], p_inst[2], p_inst[3]);

        machine_Machine_execute(self, inst);
    }
}
int main(int argc, char** argv)
{
    if (argc < 2)
    {
        puts("please supply a RV64I program to run!");
        return EXIT_FAILURE;
    }
    g_trace                     = argc > 2 && _stricmp(argv[2], "--trace") == 0;
    machine_Machine_ptr machine = malloc(sizeof(machine_Machine));
    memset(machine, 0, sizeof(machine_Machine));
    machine_Machine_loadfile(machine, argv[1]);
    machine_Machine_run(machine);
    exit((int)machine->exitcode);
    return EXIT_SUCCESS;
}
